# Verifiable Differential Privacy

Update: Make sure you have openssl installed.

**NOTE:** This is not production ready code, used only for prototyping and generating numbers reported in the paper. To reproduce expriments in the paper see instructions below. 

**Update**: In this repository we simulate inter server communication in a single thread via a for loop. A more practical setting is to follow [this example](https://github.com/henrycg/heavyhitters) and setup multiple servers (and adapt the interfaace). For the purposes of prototyping we did not find this necessary.

**Update**: The experiments below have a dependency on openssl as we use openssls big integer support to perform finite field operations. 

## Getting Started 

Make sure you have a working rust and cargo installation

```bash
$ rustc --version
rustc 1.59.0 (9d1b2106e 2022-02-23)
$ cargo --version
cargo 1.59.0
```

## Pedersen Commitments

Pedersen commitments used in schnorr are built using a subgroup $G$ of $Z_p^\star$ where $p$ is a safe prime and $q = \frac{(p-1)}{2}$. The security bits for the size of $p$ is customisable and we use [openssl](https://docs.rs/openssl/latest/openssl/bn/struct.BigNum.html#method.generate_prime) to generate the prime number. For more details see

```
src/public_parameters.rs
```

We also played around with the curve25519_dalek::ristretto curve. 

Run the following example to see how to use commitments in this library
```
cargo run --example commitments
```

## Schnorr-Sigma OR Proof

A 3 message interactive ZK proof that allows a prover to convince an efficient verifier that given $c = Com(x, r)$, $c$ is a commitment to $x=1$ or $x=0$. 

To see how to create such a proof and then its verification, run 

```
 cargo run --example schorr
```

**NOTE**: The textbook definition of a sigma protocol is **only Honest Verifier Zero-Knowledge**. It can be rendered non-interactive using the Fiat Shamir transform, which makes it ZK in the ROM model. However, the OR protocol can be made fully ZK even in the plain model.

An interactive standard sigma protocol can be made fully zero-knowledge by sampling the challenge from a set $S$ that is polynomial in the size of the security parameter. See Theorem 2 of [Maurer](https://crypto.ethz.ch/publications/files/Maurer09.pdf). A proof sketch of the simulator is provided below. A natural consequence of shrinking the challenge space is that soundness is non-negligble, but by sequential repetition, we can drive the soundness to be negligible as well.

Alternatively the 3 message sigma protocol can be extended to a [4 message protocol](https://link.springer.com/chapter/10.1007/3-540-45539-6_30) which requires the verifier to commit to their challenge before seeing the provers first message, using trapodoor commitments. [This talk by Benny Pinkas](https://youtu.be/m-NW75E8JIE) provides a full description of the protocol and a simulator proof. Not only is this proof fully ZK, it can be also used concurrently.

### Maurer's Proof of Theorem 2 

In Mauer's proof sketch for Theorem 2, he is suggesting that the simulator repeatedly choose the challenge $c$ at random, and use "c-simulatability" to generate a transcript $(a, c, z)$ distributed identically to those generated by the honest prover interacting with the verifier when the challenge is $c$.

With this procedure, the probability that the simulator picks a $c$ such that the dishonest verifier V would have actually sent $c$ in response to the first-message being $a$, and such that V would have accepted $(a, c, z)$ is:

$$ \star = \sum_{c \in S} \Pr[\text{simulator picks challenge c}] \times q(c)$$


where $q(c) = \Pr[A]$ and $A$ is the event that the malicious $V$ winds up sending challenge $c$ when interacting with honest prover, and accepting the resulting transcript

As $|S|$ is polynomial, we have for at least one $c^\star$, $q(c^\star)$ must be non-negligible. This is because the probability of the dishonest $V$ accepting when interacting with the honest prover is $\sum_{c \in S} q(c)$ and, $\sum_{c \in S} q(c)$ is negligible if $q(c)$ is negligible for all $c$

Hence, the equation denoted by $(\star)$ above at least $(1/|S|) \times q(c^\star)$, which is non-negligible since $|S|$ is polynomial and $q(c^\star)$ is non-negligible. 

## How to generate numbers for the paper

All plots in the paper were generated by setting the security parameter to 512. Specifically, the first line in the programs below has the following variable. The output from the command line can be redirected into any plotting software of your choice.

```
    let security_parameter = 512;

```

To generate numbers for Table 1, run 
```
cargo run --example counting_query

   Compiling dp_client v0.1.0 (/Users/ari/Projects/Verifiable-Differential-Privacy)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/examples/counting_query`
Found a generator
Epsilon:	Proof Creation	Proof Verification	Number Of Coins	Morra
452.55:	[0,	0,	1,	0]
320.00:	[0,	0,	2,	0]
226.27:	[0,	0,	4,	0]
160.00:	[0,	0,	8,	0]
113.14:	[0,	0,	16,	0]
80.00:	[1,	1,	32,	0]
56.57:	[2,	2,	64,	1]
40.00:	[4,	4,	128,	2]
28.28:	[7,	7,	256,	5]
20.00:	[13,	13,	512,	9]
14.14:	[25,	26,	1024,	19]
10.00:	[51,	52,	2048,	37]
7.07:	[103,	104,	4096,	76]
5.00:	[206,	208,	8192,	151]
...
```

To generate numbers for Figure 4, run 

```
cargo run --example prio_simulation

    Finished dev [unoptimized + debuginfo] target(s) in 0.77s
     Running `target/debug/examples/prio_simulation`
Found a generator
2:16,
4:24,
8:41,
16:74,
32:124,
64:243,
128:389,
256:655,
512:1167,
1024:2310,
2048:4606,
4096:9234,
8192:18360,

cargo run --example poplar_simulation

```
